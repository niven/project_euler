#include <stdio.h>
#include <stdint.h>
#include <math.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

/*

Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P_4 + P_7 = 22 + 70 = 92 = P_8. However, their difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, P_j and P_k, for which their sum and difference are pentagonal and D = |P_k − P_j| is minimised; what is the value of D?

So a pentagonal number is actually also 5x(triangle) - 5*edge (because there are 5 overlaps) - 4 (since the middle overlaps all 5)
Ah, it seems the assignment is not for filled pentagons, but just the 'borders' of them
(the filled sequence would be: 1, 6, 16 etc )

So if we just make some equations:

n(3n-1)/2 + m(3m-1)/2 = p(3p-1)/2
and
n(3n-1)/2 - m(3m-1)/2 = q(3q-1)/2

We have 2 equations with 4 variables
if only we had 3 somehow..
maybe we can rewrite the leftmost parts as 1?
r=(m-n) or something?

Maybe just start with D, and find if there is a diff/sum out there, and keep increasing D?
That would ensure D is minimized, but it would mea finding P_ns all smaller than D to split it up

(3n^2-n) - (3m^2-m) = 3q^2 - q
So that means D(4) is 3 stacked squares of width 4 minus a line of 4
That is a rect of 11x4 = 44
So does that mean we need to find 2 other rects that when subtracted form into 4x11?
Does that mean those rects are also factorable as Ax4 and Bx4? (or 11?)


Anyway: back to the drawing board: they are in fact talking about filled pentagonal numbers,
since they are overlaid (and not 'grow outward') 


|---------b-----------|------a-----| Pb+Pa
|------------------c---------------| Pc
|--d---|------a-------+-----a------| Pd + 2Pa

So we start at P(d=1) and find Pa so that Pd+2Pa==Pc is_pentagonal, and then check if Pd+Pa==Pb is_pentagonal

How does this guarantee Pd is minimal though? When do we stop growing Pa and decide to go to the next Pd?

Let's first just try some (that didn't work for d up to 1000 and a up to 10,000)

Maybe start with Pc, and then iterate d from 1..c and check for (Pc-Pd)/2 is_pent
Ok, so that works, but I dont know if that proves Pd is minimal:

if we are at c=100 and find a solution for d=20, there still could be a solution for c=200 and d=3 I think.
*/

uint64_t pentagonal( int n ) {
	
	uint64_t result = 0;
	
	// do it like this to avoid problems with dividing odd numbers too soon
	result = (n* (3*n - 1 ) ) / 2;
	
	return result;
}

/*
	Search keys for a target_key.
	returns
		BINSEARCH_FOUND: target is an element of ordered_list, target_index is set to the location
		BINSEARCH_INSERT: target is NOT an element of ordered_list, target_index is set to the index where you would need to insert target
		BINSEARCH_ERROR: ordered_list is NULL, key_index is unchanged

*/
#define BINSEARCH_ERROR 0
#define BINSEARCH_FOUND 1
#define BINSEARCH_INSERT 2

unsigned char binary_search( uint64_t* ordered_list, uint64_t list_size, uint64_t target, uint64_t* target_index ) {

	// no data at all
	if( ordered_list == NULL ) {
		return BINSEARCH_ERROR;
	}
	
	// empty array, or insert location should be initial element
	if( list_size == 0 || target < ordered_list[0] ) {
		*target_index = 0;
		return BINSEARCH_INSERT;
	}
	
	uint64_t span = list_size;
	uint64_t mid = list_size / 2;
	uint64_t large_half;
	while( span > 0 ) {

		if( target == ordered_list[mid] ) {
			*target_index = mid;
			return BINSEARCH_FOUND;
		}
		
		span = span/2; // half the range left over
		large_half = span/2 + (span % 2);// being clever. But this is ceil 

		if( target < ordered_list[mid] ) {
			mid -= large_half;
		} else {
			mid += large_half;
		}
		
	}

	// target_key is not an element of keys, but we found the closest location
	if( mid == list_size ) { // after all other elements
		*target_index = list_size;
	} else if( target < ordered_list[mid] ) {
		*target_index = mid; // displace, shift the rest right
	} else if( target > ordered_list[mid] ) {
		*target_index = mid+1; // not sure if these two are both possible
	} else {
		assert(0); // cannot happen
	}


	// correctness checks:
	// 1. array has elements, and we should insert at the end, make sure the last element is smaller than the new one
	if( list_size > 0 && *target_index == list_size ) {
		assert( target > ordered_list[list_size-1] );
	}
	// 2. array has no elements (we already check this above, but left for completeness)
	if( list_size == 0 ) {
		assert( *target_index == 0 );
	}
	// 3. array has elements, and we should insert at the beginning
	if( list_size > 0 && *target_index == 0 ) {
		assert( target < ordered_list[0] ); // MUST be smaller, otherwise it would have been found if equal
	}
	// 4. insert somewhere in the middle
	if( *target_index > 0 && *target_index < list_size ) {
		assert( target < ordered_list[*target_index] ); // insert shifts the rest right, MUST be smaller otherwise it would have been found
		assert( ordered_list[*target_index-1] < target ); // element to the left is smaller
	}

	return BINSEARCH_INSERT;
}

int is_pentagonal( uint64_t p, uint64_t* pents, int pent_count ) {

	uint64_t pentagonal_index = 0;
	int result = binary_search( pents, pent_count, p, &pentagonal_index );
	
	return result == BINSEARCH_FOUND ? pentagonal_index : 0;

	// this is a nice check, but since we precalc the pents, might as well binsearch that list
#if 0	
	// p must be of the form n(3n-1)/2
	// or 3/2 * n^2 - 1/2*n
	// which means that n < sqrt(p)
	uint64_t max_n = sqrt(p);
	// printf("Max n=%llu for %llu\n", max_n, p );
	// now count backwards
	for( int n=max_n; n>=0; n-- ) {
		uint64_t Pn = pentagonal(n);
		if( Pn == p ) {
			return 1;
		}
		if( Pn < p ) {
			return 0;
		}
	}
	
	return 0;	
#endif
}


int main(int argc, char** argv) {
	
	uint64_t result = 0;
	int maxc=100*1000; // well, I found the actual bound after solving the problem (c=2395)
	uint64_t pent[maxc];
	// for( int i=0; i<maxc; i++ ) {
	// 	pent[i] = pentagonal(i);
	// }
	maxc=0;
	int c=1;
	while( 1 ) {
		
		uint64_t Pc = pentagonal(c);
		pent[c] = Pc;
		maxc++;
		c++;
		
		for(int d=1; d<c; d++ ) {
			uint64_t Pd = pent[d];
			uint64_t Pa_twice = Pc-Pd;
			if( Pa_twice % 2 == 1 ) {
				continue; // can't be odd
			}
			uint64_t Pa = Pa_twice/2;

			if( is_pentagonal(Pa, pent, maxc) != 0 ) {
				// printf("c=%d, d=%d, Pa=%llu is pent: %d\n", c, d, Pa, is_pentagonal(Pa));
				uint64_t Pb = Pc - Pa;
				if( is_pentagonal(Pb, pent, maxc) != 0 ) {
					// printf("Pb: %llu, is pent: %d\n", Pb, is_pentagonal(Pb, pent, maxc));
					// printf("Pa=%llu\tPb=%llu\tPc=%llu+%llu==%llu==%llu,Pd=%llu==%llu-%llu==%llu\n", Pa, Pb, Pa,Pb, Pc,Pa+Pb, Pd,Pb,Pa, Pb-Pa);
					result = Pd;
					goto FOUND_AND_DONE;
				}
			}
		}
	}

FOUND_AND_DONE:
	
	printf("Problem 044: %llu\n", result );
}
