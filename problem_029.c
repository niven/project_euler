#include <stdio.h>
#include <stdint.h>
#include <math.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

/*

Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

    2^2=4, 2^3=8, 2^4=16, 2^5=32
    3^2=9, 3^3=27, 3^4=81, 3^5=243
    4^2=16, 4^3=64, 4^4=256, 4^5=1024
    5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

One could of course produce the small list of 100x100=10K results, but that would be too easy I would think.
On second thought: those numbers would be wayyy too big :)

We can just count every option of a_i^b_j as one result, and taking care that all are normalized first
Example: 4^2=16 = 2^4 so that means factoring the base because
8^n = 2^3n etc

So that's what I tried for a bit, but I got lost in trying to "move" a^b to a higher/lower one. This leads to
trouble when 32^2 = 1024 = 4^5 etc, you can't really bound where to go since any higher base may then be a power
of a smaller number. What does make sense is reducing every power to it's lowest base and then iterating all
possible divisors of that exponent (which will get you all ways to express that power, including the original) 
which can then be checked against the max.


*/

typedef struct power {
	int a;
	int b;
} power;

power reduce( int base, int exponent ) {
	
	for( int i=2; i<base; i++ ) {
		
		int start = base;
		int power = 0;
		while( start > 1 && start % i == 0 ) {
			start /= i;
			power++;
		}
		if( start == 1 ) {
			// printf("DOne: %d^%d = %d^%d\n", base, exponent, i, power*exponent );
			return (struct power){ .a = i, .b = power*exponent };
		}
		
	}
	
	return (struct power){ .a = base, .b = exponent };
}


int main(int argc, char** argv) {
	
	uint64_t result = 0;
	
	int max = 100;

	int double_counter = 0;
	int counter = 0;
	int c=0;
	for( int a=2; a<=max; a++ ) {
		for( int b=2; b<=max; b++ ) {

			power p = reduce( a, b );
			// printf("Checking %d^%d => %d^%d\n", a ,b, p.a, p.b);
			
			if( a == p.a && b == p.b ) {
				// printf("\tCan't reduce, counting\n");
				counter++;
			} else {
				// if this is a lower base with an exponent up to max, then this was counted earlier
				// now go over all the divisors of the exponent and re-express as different powers
				// Note: start at 1 so the reduced form will be the first check, which is nicer and
				// avoids an if
				for( int i=1; i<p.b; i++ ) {
					if( p.b % i == 0 ) {
						// printf("\tRewriteable with exponent %d\n", p.b/i );
						power temp = { .a = 1, .b = p.b/i };
						
						// Do it one by one to avoid overflow (and needless extra work)
						int num = i;
						while( num --> 0 ) {
							temp.a *= p.a;
							// printf("\t\ttemp = %d^%d\n", temp.a, temp.b);
							if( temp.a > max ) {
								break;
							}
						}
						
						// now we have a re-expressed a^b, or one that grew its base too large
						if( num != -1 ) {
							// printf("\tBase outgrew max\n");
						} else if( temp.b > max ) {
							// printf("\tExponent outgrew max\n");
						} else {
							// printf("\tValid new expression %d^%d\n", temp.a, temp.b);
							if( temp.a < a ) {
								// printf("\tHas been counted at lower base\n");
								double_counter++;
								break; // To bo fair, hard to see where this breaks :) goes to next b
							} else if( temp.a == a ) {
								// printf("\tCounting for itself!\n");
								counter++;
								break; // Also next b: any further rewriting would make he base larger than a
							} else {
								// printf("\tWill be counted at higher base\n");
							}
						}
					}
				}
				
			}
			
		}
	}
	// printf("Counter: %d\n", counter);
	// printf("Doublec: %d\n", double_counter);
	// printf("Space  : %d = %d\n", (max-1)*(max-1), counter+double_counter);
	
	// not sure why we're not including 0,1 since that just gives an extra 0,1 in every series.
	result = (max-1) * (max-1);
	result -= double_counter;

	printf("Problem 029: %llu\n", result );

}
